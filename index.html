<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Tramac写字的地方">
<meta property="og:type" content="website">
<meta property="og:title" content="Tramac">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Tramac">
<meta property="og:description" content="Tramac写字的地方">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tramac">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Tramac</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Tramac" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tramac</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83-PyTorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83-PyTorch/" class="post-title-link" itemprop="url">并行训练-PyTorch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:29:56" itemprop="dateCreated datePublished" datetime="2020-07-17T14:29:56+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当我们的设备具有多个GPUs时，为了训练加速，我们通常会选用多卡并行训练，常见的并行训练方式有数据并行和模型并行。而PyTorch中也给我们提供了数据并行的接口<a href="https://github.com/pytorch/pytorch/blob/master/torch/nn/parallel/data_parallel.py" target="_blank" rel="noopener">DataParalle</a>。本文将对该并行过程做一个简单的总结。</p>
<h4 id="1-数据并行示意图"><a href="#1-数据并行示意图" class="headerlink" title="1. 数据并行示意图"></a>1. 数据并行示意图</h4><p><a href="https://tramac.github.io/2019/03/29/Pytorch并行训练/singleGPU.png" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/03/29/Pytorch%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83/singleGPU.png" alt="img"></a></p>
<p><a href="https://tramac.github.io/2019/03/29/Pytorch并行训练/parallelmodel.png" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/03/29/Pytorch%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83/parallelmodel.png" alt="img"></a></p>
<p><a href="https://tramac.github.io/2019/03/29/Pytorch并行训练/multiGPU.png" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/03/29/Pytorch%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83/multiGPU.png" alt="img"></a></p>
<p> (a) single GPU (b) parallel model (c) parallel citerion</p>
<h4 id="2-DataParallel过程分析"><a href="#2-DataParallel过程分析" class="headerlink" title="2. DataParallel过程分析"></a>2. DataParallel过程分析</h4><p>本文将通过分析PyTorch中<a href="https://github.com/pytorch/pytorch/blob/master/torch/nn/parallel/data_parallel.py" target="_blank" rel="noopener">DataParallel</a>源码的方式对并行过程展开讨论。Note:本文中只展示核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class DataParallel(Module):</span><br><span class="line">    def __init__(self, module, device_ids&#x3D;None, output_device&#x3D;None, dim&#x3D;0):</span><br><span class="line">        super(DataParallel, self).__init__()</span><br><span class="line">    </span><br><span class="line">    def forward(self, *inputs, **kwargs):</span><br><span class="line">        # 1.将输入batch data分解</span><br><span class="line">        inputs, kwargs &#x3D; self.scatter(inputs, kwargs, self.device_ids)</span><br><span class="line">        # 2.将model在每个GPU上各复制一份</span><br><span class="line">        replicas &#x3D; self.replicate(self.module, self.device_ids[:len(inputs)])</span><br><span class="line">        # 3.进行并行前向计算</span><br><span class="line">        outputs &#x3D; self.parallel_apply(replicas, inputs, kwargs)</span><br><span class="line">        # 4.将分解后的计算结果重新聚集，合成为原始的batch大小</span><br><span class="line">        return self.gather(outputs, self.output_device)</span><br></pre></td></tr></table></figure>

<p>数据并行的主要过程就是包括上面4个步骤，结合图1(b)来看更加直观。</p>
<h4 id="3-DataParallelModel和DataParallelCriterion拓展"><a href="#3-DataParallelModel和DataParallelCriterion拓展" class="headerlink" title="3. DataParallelModel和DataParallelCriterion拓展"></a>3. DataParallelModel和DataParallelCriterion拓展</h4><p>在PyTorch官方提供的DataParallel接口中，是从输入x到输出y的过程，但是，在我们通常的训练过程中，我们还需要计算输入y与label之间的损失Loss，所以，为了加速到底，最好是将loss的计算也在过个GPU上进行。<a href="https://github.com/Tramac/Awesome-semantic-segmentation-pytorch/blob/master/utils/parallel.py" target="_blank" rel="noopener">DataParallelCriterion</a>的过程主要参考了<a href="https://github.com/zhanghang1989/PyTorch-Encoding" target="_blank" rel="noopener">PyTorch-Encoding</a>中的代码，代码质量很高，强烈推荐一波:+1:</p>
<p>在DataParallelCriterion之前，我们首先需要对原始的DataParallel进行修改，即返回结果时不让其执行gather聚集过程，因为我们接下来还要在每个分解batch上继续计算loss。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class DataParallelModel(DataParallel):</span><br><span class="line">    # 修改gather过程，使其直接返回</span><br><span class="line">    def gather(self, outputs, output_device):</span><br><span class="line">        return outputs</span><br></pre></td></tr></table></figure>

<p>为了并行计算loss，主要的不同是需要将batch label同样划分为多个子batch。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DataParallelCriterion(DataParallel):</span><br><span class="line">    def forward(self, inputs, *targets, **kwargs):</span><br><span class="line">        # 对label进行分解</span><br><span class="line">        targets, kwargs &#x3D; self.scatter(targets, kwargs, self.device_ids)</span><br><span class="line">        # 将model在每个GPU上各复制一份</span><br><span class="line">        replicas &#x3D; self.replicate(self.module, self.device_ids[:len(inputs)])</span><br><span class="line">        # 执行前向计算，具体函数在这里不做展示，详细可见链接内容</span><br><span class="line">        outputs &#x3D; criterion_parallel_apply(replicas, inputs, targets, kwargs)</span><br><span class="line">        return Reduce.apply(*outputs) &#x2F; len(outputs)</span><br></pre></td></tr></table></figure>

<p>整个并行训练过程如上所述，可结合图1(c)理解。</p>
<h4 id="3-并行训练中的注意事项"><a href="#3-并行训练中的注意事项" class="headerlink" title="3. 并行训练中的注意事项"></a>3. 并行训练中的注意事项</h4><ul>
<li>所有的划分都是在batch维度进行</li>
<li>batch size必须大于GPUs的数量，最好是保证是其数量的整数倍</li>
</ul>
<h4 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h4><ul>
<li><a href="https://github.com/Tramac/Awesome-semantic-segmentation-pytorch" target="_blank" rel="noopener">Awesome-semantic-segmentation-pytorch</a></li>
<li><a href="https://github.com/zhanghang1989/PyTorch-Encoding" target="_blank" rel="noopener">PyTorch-Encoding</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E8%B7%A8%E5%8D%A1%E5%90%8C%E6%AD%A5%20Batch%20Normalization[%E8%BD%AC]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E8%B7%A8%E5%8D%A1%E5%90%8C%E6%AD%A5%20Batch%20Normalization%5B%E8%BD%AC%5D/" class="post-title-link" itemprop="url">跨卡同步 Batch Normalization[转]</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:29:12" itemprop="dateCreated datePublished" datetime="2020-07-17T14:29:12+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作者：<a href="https://hangzhang.org/" target="_blank" rel="noopener">张航</a> Amazon AI Applied Scientist</p>
<p>跨卡同步（Cross-GPU Synchronized）Batch Normalization或称为同步BN（SyncBN）。</p>
<h4 id="写在前面：为什么要跨卡同步Batch-Normalization"><a href="#写在前面：为什么要跨卡同步Batch-Normalization" class="headerlink" title="写在前面：为什么要跨卡同步Batch Normalization"></a>写在前面：为什么要跨卡同步Batch Normalization</h4><p>现有的便准Batch Normalization因为使用数据并行（Data Parallel），是单卡的实现模式，只对单个卡上对样本进行归一化，相当于减小了批量大小（batch-size）。对于比较消耗显存的训练任务时，往往单卡上的相对批量过小，影响模型的收敛效果。之前在我们在图像语义分割的实验中，发现使用大规模的效果反而变差，实际上就是BN在作怪。跨卡同步Batch Normalization 可以使用全局的样本进行归一化，这样相当于‘增大’了批大小，这样训练效果不再受到使用GPU数量的影响。最近在图像分割、物体检测的论文中，使用跨卡BN也会显著地提高实验结果，所以跨卡BN已然成为竞赛刷分、发论文的必备神器。</p>
<h4 id="Batch-Normalization如何工作"><a href="#Batch-Normalization如何工作" class="headerlink" title="Batch Normalization如何工作"></a>Batch Normalization如何工作</h4><p>既然是技术贴，读者很多都是神学大牛，为什么还要在这里赘述BatchNorm这个简单概念呢？其实不然，很多做科研的朋友如果没有解决过相关问题，很容易混淆BN在训练和测试时候的工作方式。记得在17年CVPR的<a href="http://deeplearning.csail.mit.edu/" target="_blank" rel="noopener">tutoial</a>上，何凯明和RBG两位大神分别在自己的talk上都特意强调了BN的工作原理，可见就算台下都是CV学者，也有必要复习一遍这些知识。</p>
<ul>
<li><p>工作原理：</p>
<p>BN有效地加速了模型训练，加大learning rate，让模型不再过度依赖初始化。它在训练时在网络内部进行归一化（normalization），为训练提供了有效的regularization，抑制过拟合，用原作者的话时防止了协方差偏移。这里上一张图来展示训练模式的BN：</p>
<p><a href="https://tramac.github.io/2019/04/08/SyncBN/batchnorm.jpg" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/04/08/SyncBN/batchnorm.jpg" alt="img"></a></p>
<p>其中输入样本，其均值为u，方差为sigma，BN的输出，时可学习对参数。个人认为，这种强大的效果其实来自于back-propagation时候，来自于均值和方差对输入样本的梯度。这也是BN在训练模式与其测试模式的重要区别，在测试模式时（evaluation mode）下，使用训练集上累积的均值和方差，在back-propagation的时候他们对输入样本没有梯度（gradient）。</p>
</li>
<li><p>数据并行：</p>
<p>深度学习平台在多卡（GPU）运算的时候都是采用的数据并行（DataParallel），如下图：</p>
<p><a href="https://tramac.github.io/2019/04/08/SyncBN/DataParallel.jpg" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/04/08/SyncBN/DataParallel.jpg" alt="img"></a></p>
<p>每次迭代，输入被等分成多份，然后分别在不同的卡上面前向（forward）和后向（backward）运算，并且求出梯度，在迭代完成后合并梯度、更新参数，再进行下一次迭代。因为再前向和后向运算的时候，每个卡上的模型是单都运算的，所以相应的Batch Normalization也是在卡内完成，所以实际BN所归一化的样本数量仅仅局限在卡内，相当于批量大小（batch-size）见笑了。</p>
</li>
</ul>
<h4 id="如何实现SyncBN"><a href="#如何实现SyncBN" class="headerlink" title="如何实现SyncBN"></a>如何实现SyncBN</h4><p>跨卡同步BN的关键是前向运算的时候拿到全局的均值和方差，在后向运算时得到相应的全局梯度。最简单的实现方法是先同步求均值，再发回各卡然后同步求方差，但是这样就同步了两次。实际上需要同步一次就可以了，我们使用了一个非常简单的技巧，如下图：</p>
<p><a href="https://tramac.github.io/2019/04/08/SyncBN/SyncBN.jpg" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/04/08/SyncBN/SyncBN.jpg" alt="img"></a></p>
<p>这样在前向运算的时候，我们只需要在各卡上算出与，再跨卡求出全局的和即可得到正确的均值和方差， 同理我们在后向运算的时候只需同步一次，求出相应的梯度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/PyTorch%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8AFinetunning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/PyTorch%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8AFinetunning/" class="post-title-link" itemprop="url">PyTorch参数初始化及Finetunning</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:28:38" itemprop="dateCreated datePublished" datetime="2020-07-17T14:28:38+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PyTorch的代码中很多都有显式的参数初始化过程（默认的初始化形式是什么？），本文将对其做一个总结。</p>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>参数的初始化其实就是对参数进行赋值。网络中所需要学习的参数其实都是<code>Variable</code>，它其实是对<code>Tensor</code>的封装，同时提供了<code>data</code>，<code>grad</code>等接口，这就意味着我们可以直接对这些参数进行赋值操作。这就是PyTorch简洁高效所在。</p>
<p><a href="https://tramac.github.io/2019/04/08/PyTorch参数初始化及Finetunning/variable.png" target="_blank" rel="noopener"><img src="https://tramac.github.io/2019/04/08/PyTorch%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8AFinetunning/variable.png" alt="img"></a></p>
<p>PyTorch中有多种初始化方式，但是其作者所推崇的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def weight_init(m):</span><br><span class="line">    if isinstance(m, nn.Conv2d):</span><br><span class="line">        n &#x3D; m.kernel_size[0] * m.kernel_size[1] * m.out_channels</span><br><span class="line">        m.weight.data.normal_(0, math.sqrt(2. &#x2F; n))</span><br><span class="line">    elif isinstance(m, nn.BatchNorm2d):</span><br><span class="line">        m.weight.data.fill_(1)</span><br><span class="line">        m.bias.data.zero_()</span><br></pre></td></tr></table></figure>

<h2 id="Finetunning"><a href="#Finetunning" class="headerlink" title="Finetunning"></a>Finetunning</h2><p>通常在加载了预训练模型的参数之后，我们需要finetune模型，一般有以下两种方式：</p>
<h4 id="局部微调"><a href="#局部微调" class="headerlink" title="局部微调"></a>局部微调</h4><p>冻结其它层，只调节最后的几层。其实不训练也就意味着不进行梯度计算，PyTorch中提供的<code>requires_grad</code>使得对训练的控制变得非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model &#x3D; torchvision.models.resnet18(pretrained&#x3D;True)</span><br><span class="line">for param in model.parameters():</span><br><span class="line">    param.requires_grad &#x3D; False</span><br><span class="line"># 替换最后的全连接层，新构造的模块的参数默认requires_grad&#x3D;True</span><br><span class="line">model.fc &#x3D; nn.Linear(512, 100)</span><br><span class="line"></span><br><span class="line"># 只优化最后的分类层</span><br><span class="line">optimizer &#x3D; optim.SGD(model.fc.parameters(), lr&#x3D;1e-2, momentum&#x3D;0.9)</span><br></pre></td></tr></table></figure>

<h4 id="全局微调"><a href="#全局微调" class="headerlink" title="全局微调"></a>全局微调</h4><p>对全局都进行finetune，但是希望该换过的层和其它层的学习率不同，这是可以把其它层和新层在<code>optimizer</code>中单独赋予不同的学习率。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ignored_params &#x3D; list(map(id, model.fc.parameters()))</span><br><span class="line">base_params &#x3D; filter(lambda p: id(p) not in ignored_params,</span><br><span class="line">                     model.parameters())</span><br><span class="line"></span><br><span class="line">optimizer &#x3D; torch.optim.SGD([</span><br><span class="line">            &#123;&#39;params&#39;: base_params&#125;,</span><br><span class="line">            &#123;&#39;params&#39;: model.fc.parameters(), &#39;lr&#39;: 1e-3&#125;</span><br><span class="line">            ], lr&#x3D;1e-2, momentum&#x3D;0.9)</span><br></pre></td></tr></table></figure>

<p>其中<code>base_params</code>使用<code>1e-3</code>来训练，<code>model.fc.parameters</code>使用<code>1e-2</code>来训练，<code>momentum</code>是二者共有的。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://blog.csdn.net/u012759136/article/details/65634477" target="_blank" rel="noopener">PyTorch参数初始化和Finetune</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC9%E7%AB%A0%20%E5%9B%BE%E5%83%8F%E5%B1%80%E9%83%A8%E4%B8%8E%E5%88%86%E5%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC9%E7%AB%A0%20%E5%9B%BE%E5%83%8F%E5%B1%80%E9%83%A8%E4%B8%8E%E5%88%86%E5%89%B2/" class="post-title-link" itemprop="url">第9章 图像局部与分割</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:26:39" itemprop="dateCreated datePublished" datetime="2020-07-17T14:26:39+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="局部与分割"><a href="#局部与分割" class="headerlink" title="局部与分割"></a>局部与分割</h4><p>简单来讲，分割就是如何从图像中将目标或部分目标分割出来。处了从图像中分割出前景目标之外，在很多情况下我们也希望将感兴趣的目标区域分割出来。<br>本章主要研究其他用于查找、填充和分离一幅图像中的目标以及部分目标物体的算法。</p>
<h4 id="背景减除（背景差分）"><a href="#背景减除（背景差分）" class="headerlink" title="背景减除（背景差分）"></a>背景减除（背景差分）</h4><p>由于背景减除简单而且摄像机在很多情况下是固定的，在视频安全领域，背景减除也许是最基本的图像处理操作。所以，背景模型的建立至关重要。<br>一旦背景模型建立，将背景模型和当前的图像进行比较，然后减去这些已知的背景减除，则剩下的目标物大致就是所求的前景目标了。<br>当然，“背景”在不同的应用场合下是一个很难定义的问题，后续会介绍一些背景建模的方法。</p>
<ul>
<li><strong>背景减除的缺点</strong></li>
</ul>
<p>背景减除的一个缺点是建立在一个不常成立的假设：所有像素点是独立的。因为这种建模方法在计算像素变化时并没有考虑它相邻的像素。<br>其中一种解决方式是建立一个多元模型，它把基本的像素独立模型扩展为包含了相邻像素的亮度的基本场景。在这种情况下，我们用相邻像素的亮度来区别相邻像素值的相对明暗。但是这种模型消耗两倍的内存和更多的计算量。<br>但是在实际应用中，由于额外的开销，通常会避免使用复杂的模型。当像素独立假设不成立情况下，我们可以更有效地把精力投入到清除那些错误的检测结果中。本章将通过使用连通域，并且后续的方法严格限制在像素变化独立的假设基础上。</p>
<ul>
<li><strong>场景建模</strong></li>
</ul>
<p>通常，一个场景模型可能包含许多层次，从新的场景到旧的场景再到背景。</p>
<ul>
<li><strong>像素片段</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对任意直线上的像素进行采样</span><br><span class="line">int cvInitLineIterator(</span><br><span class="line">    const CvArr* image,</span><br><span class="line">    CvPoint pt1,</span><br><span class="line">    CvPoint pt2,</span><br><span class="line">    CvLineIterator* line_iterator,</span><br><span class="line">    int connectivity&#x3D;8,</span><br><span class="line">    int left_to_right&#x3D;0</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>帧差</strong></li>
</ul>
<p>最简单的背景减除方法就是用一帧减去另一帧，然后将足够大的差别标为前景。这种方法往往能捕捉运动目标的边缘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算帧差</span><br><span class="line">cvAbsDiff(frameTime1, frameTime2, frameForeground);</span><br></pre></td></tr></table></figure>



<p>由于像素值总会受到噪声和波动的影响，我们应该忽略很小的差异，标识其余的作为较大的差别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cvThreshold(frameForeground, frameForeground, 15, 255, CV_THRESH_BINARY);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>平均背景法</strong></li>
</ul>
<p>平均背景法的基本思路是计算每个像素的平均值和标准差作为它的背景模型。</p>
<ul>
<li><strong>累积均值、方差和协方差</strong></li>
</ul>
<p>在平均背景法中，一个常用的函数是累积函数cvAcc()。通过该操作，我们可以计算出整个场景或部分场景的基本统计特性（均值，方差和协方差）。<br><strong>均值漂移值</strong>：通过大量图像计算每个像素的均值的最简单的方法就是调用函数cvAcc()把他们加起来再除以图像总数来获得均值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void cvAcc(</span><br><span class="line">    const CvArr* image,</span><br><span class="line">    CvArr* sum,</span><br><span class="line">    const CvArr* mask&#x3D;NULL</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 直接计算均值漂移</span><br><span class="line">void cvRunningAvg(</span><br><span class="line">    const CvArr* image,</span><br><span class="line">    CvArr* acc,</span><br><span class="line">    double alpha,</span><br><span class="line">    const CvArr* mask&#x3D;NULL;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p><strong>计算方差</strong>：可以通过累积平方图像，快速计算单个像素的方差。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void cvSquareAcc(</span><br><span class="line">    const CvArr* image,</span><br><span class="line">    CvArr* sqsum,</span><br><span class="line">    const CvArr* mask&#x3D;NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p><strong>计算协方差</strong>：可以通过选择一个特定的时间间隔来观测图像是怎么变化的，然后用当前图像乘以和特定时间间隔相对应的图像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算协方差</span><br><span class="line">void cvMultiplyAcc(</span><br><span class="line">    const CvArr* image1,</span><br><span class="line">    const CvArr* image2,</span><br><span class="line">    CvArr* acc,</span><br><span class="line">    const CvArr* mask&#x3D;NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>高级背景模型</strong></li>
</ul>
<p>codebook由一些boxes组成，这些boxes包含很长时间不变的像素值。codebook方法能够解决像素剧烈变化的问题。<br><strong>结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; codebook结构体定义</span><br><span class="line">typedef struct code_book&#123;</span><br><span class="line">    code_element **cb;</span><br><span class="line">    int numEntries;</span><br><span class="line">    int t;</span><br><span class="line">&#125; codebook;</span><br></pre></td></tr></table></figure>



<p><strong>背景学习</strong><br>略<br><strong>学习有移动前景目标的背景</strong><br>略<br><strong>背景差分：寻找前景目标</strong><br>略<br><strong>使用codebook背景模型流程总结</strong>:<br>1.使用函数update_codebook()在几秒钟或几分钟时间内训练一个基本的背景模型。<br>2.调用函数clear_stale_entries()清除stale索引。<br>3.调整阈值minMod和maxMod对已知前景达到最好的分割。<br>4.保持一个更高级别的场景模型。<br>5.通过函数background_diff()使用训练好的模型将前景从背景中分割出来。<br>6.定期更新学习的背景像素。<br>7.在一个频率较慢的情况下，用函数clear_stale_entries()定期清理stale的codebook索引。</p>
<ul>
<li><strong>用于前景清除的连通部分</strong></li>
</ul>
<p>使用连通成分分析来清理原始分割图像是另一种寻找轮廓的方法。它能从原始噪声掩模图像创建出完整的掩模图像。连通域法是一个功能强大的在背景减去中去除噪声的技术。<br>下面直接给出一些处理连通区域的主要功能：<br>1.采用多边形拟合存在的轮廓部分，或凸包设置连通轮廓有多大<br>2.设置连通轮廓的大小以保证不被删除<br>3.设置返回的连通轮廓的最大数目<br>4.可选返回存活的连通轮廓的外接矩形<br>5.可选返回存活连通轮廓的中心</p>
<h4 id="分水岭算法"><a href="#分水岭算法" class="headerlink" title="分水岭算法"></a>分水岭算法</h4><p>在许多实际情况下，我们要分割图像，但无法从背景图像中获得有用信息。分水岭算法在这方面往往是有效的。<br>更确切的说，分水岭算法允许用户来标记目标的某个部分为目标，或背景的某个部分为背景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分水岭算法函数</span><br><span class="line">void cvWatershed(const CvArr* image, CvArr* markers);</span><br></pre></td></tr></table></figure>



<h4 id="用Inpainting修补图像"><a href="#用Inpainting修补图像" class="headerlink" title="用Inpainting修补图像"></a>用Inpainting修补图像</h4><p>图像常常被噪声腐蚀。这些噪声也许是镜头上的灰尘或水滴造成的，也可能是旧照片上的划痕，或者图像的部分已经被破坏了。Inpainting是修复这些损害的一种有效方法，它可以利用这些已经破坏区域的边缘的颜色和结构，繁殖和混合到损坏的图像里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void cvInpaint(</span><br><span class="line">    const CvArr* src,</span><br><span class="line">    const CvArr* mask,</span><br><span class="line">    CvArr* dst,</span><br><span class="line">    double inpaintRadius,</span><br><span class="line">    int flags</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="均值漂移分割"><a href="#均值漂移分割" class="headerlink" title="均值漂移分割"></a>均值漂移分割</h4><p>均值漂移能沿时间轴找到颜色空间的峰值分布。这里均值漂移分割能找到在空间上颜色分布的峰值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 均值漂移分割</span><br><span class="line">void cvPyrMeanShiftFiltering(</span><br><span class="line">    const CvArr* src,</span><br><span class="line">    CvArr* dst,</span><br><span class="line">    double spatialRadius,</span><br><span class="line">    double colorRadius,</span><br><span class="line">    int max_level&#x3D;1,</span><br><span class="line">    CvTermCriteria termcrit&#x3D;cvTermCriteria(</span><br><span class="line">        CV_TERMCRIT_ITER | CV_TERMCRIT_EPS,</span><br><span class="line">        5,</span><br><span class="line">        1</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC8%E7%AB%A0%20%E8%BD%AE%E5%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC8%E7%AB%A0%20%E8%BD%AE%E5%BB%93/" class="post-title-link" itemprop="url">第8章 轮廓</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:26:12" itemprop="dateCreated datePublished" datetime="2020-07-17T14:26:12+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>OpenCV使用内存存储器(memory storage)来统一管理各种<strong>动态</strong>对象的内存。内存存储器在底层被实现为一个有许多相同大小的内存块组成的双向链表，通过这种结构，OpenCV可以从内存存储器中快速的分配内存或将内存返回给内存存储器。<br>内存存储器可以通过以下四个函数访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个内存存储器</span><br><span class="line">CvMemStorage* cvCreateMemStorage(int block_size&#x3D;0);</span><br><span class="line">&#x2F;&#x2F; 释放内存存储器中分配的内存</span><br><span class="line">void cvReleaseMemStorage(CvMemStorage** storage);</span><br><span class="line">&#x2F;&#x2F; 清空内存存储器</span><br><span class="line">void cvClearMemStorage(CvMemStorage* storage);</span><br><span class="line">&#x2F;&#x2F; 从一个内存存储器中申请空间</span><br><span class="line">void* cvMemStorageAlloc(CvMemStorage* storage, size_t size);</span><br></pre></td></tr></table></figure>



<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>序列是内存存储器中可以存储的一种对象。序列是某种结构的链表。OpenCV中序列可以存储多种不同的结构。序列在内存被实现为一个双端队列(deque)。因此，序列可以实现快速的随机访问，以及快速删除顶端的元素，但是从中间删除元素则稍慢些。<br>结构CVSeq的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvSeq&#123;</span><br><span class="line">    int flags;</span><br><span class="line">    int header_size;</span><br><span class="line">    CvSeq* h_prev;	&#x2F;&#x2F; 指向前一序列</span><br><span class="line">    CvSeq* h_next;	&#x2F;&#x2F; 指向下一序列</span><br><span class="line">    CvSeq* v_prev;</span><br><span class="line">    CvSeq* v_next;</span><br><span class="line">    int total;</span><br><span class="line">    int elem_size;</span><br><span class="line">    char* block_max;</span><br><span class="line">    char* ptr;</span><br><span class="line">    int delta_elems;</span><br><span class="line">    CvMemStorage* storage;</span><br><span class="line">    CvSeqBlock* free_blocks;</span><br><span class="line">    CvSeqBlock* first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>创建序列</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 序列分配函数</span><br><span class="line">CvSeq* cvCreateSeq(</span><br><span class="line">    int seq_flags,	&#x2F;&#x2F; 组织数据的方式</span><br><span class="line">    int header_size,	&#x2F;&#x2F; 序列的头大小</span><br><span class="line">    int elem_size,	&#x2F;&#x2F; 序列要存储的元素的大小</span><br><span class="line">    CvMemStorage* storage	&#x2F;&#x2F; 指定内存存储器</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>删除序列</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 清空序列中的所有元素</span><br><span class="line">void cvClearSeq(CvSeq* seq);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>直接访问序列中的元素</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 随机访问某个元素</span><br><span class="line">char* cvGetSeqElem(seq, index);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印序列中的所有碘元素</span><br><span class="line">for (int i &#x3D; 0; i &lt; seq-&gt;total; ++i) &#123;</span><br><span class="line">    CvPoint* p &#x3D; (CvPoint*)cvGetSeqElem(seq, i);</span><br><span class="line">    printf(&quot;(%d, %d)\n&quot;, p-&gt;x, p-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 检测一个元素是否在序列中</span><br><span class="line">int cvSeqElemIdx(</span><br><span class="line">    const CvSeq* seq,</span><br><span class="line">    const void* element,</span><br><span class="line">    CvSeqBlock** block&#x3D;NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>切片、复制和移动序列中的数据</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 深度复制一个序列，并创建一个完全独立的序列结构</span><br><span class="line">CvSeq* cvCloneSeq(</span><br><span class="line">    const CvSeq* seq,</span><br><span class="line">    CvMemStorage* storage&#x3D;NULL</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 复制一个序列的子序列，或者仅为子序列创建一个头，和原来序列共用元素空间</span><br><span class="line">CvSeq* cvSeqSlice(</span><br><span class="line">    const CvSeq* seq,</span><br><span class="line">    CvSlice slice,</span><br><span class="line">    CvMemStorage* storage&#x3D;NULL,</span><br><span class="line">    int copy_data&#x3D;0</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 删除序列</span><br><span class="line">void cvSeqRemoveSlice(</span><br><span class="line">    CvSeq* seq,</span><br><span class="line">    CvSlice slice</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 添加序列</span><br><span class="line">void cvSeqInsertSlice(</span><br><span class="line">    CvSeq* seq,</span><br><span class="line">    int before_index,</span><br><span class="line">    const CvArr* from_arr</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 通过比较函数，对序列中的元素进行排序，或搜索一个序列</span><br><span class="line">&#x2F;&#x2F; 函数原型</span><br><span class="line">typedef int (*CvCmpFunc)(const void* a, const void* b, void* userdata);</span><br><span class="line">&#x2F;&#x2F; 对序列排序</span><br><span class="line">void cvSeqSort(</span><br><span class="line">    CvSeq* seq,</span><br><span class="line">    CvCmpFunc func,</span><br><span class="line">    void* userdata&#x3D;NULL</span><br><span class="line">);</span><br><span class="line">char* cvSeqSearch(</span><br><span class="line">    CvSeq* seq,</span><br><span class="line">    const void* elem,</span><br><span class="line">    CvCmpFunc func,</span><br><span class="line">    int is_sorted,</span><br><span class="line">    int* elem_idx,</span><br><span class="line">    void* userdata&#x3D;NULL</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 对序列进行逆序操作</span><br><span class="line">void cvSeqInvert(CvSeq* seq);</span><br><span class="line">&#x2F;&#x2F; 拆分序列</span><br><span class="line">int cvSeqPartition(</span><br><span class="line">    const CvSeq* seq,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    CvSeq** labels,</span><br><span class="line">    CvCmpFunc is_equal,</span><br><span class="line">    void* userdata</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>将序列作为栈来使用</strong></li>
</ul>
<p>序列内部实现是一个双端队列。因此，我们可以高效地从序列的任意一段访问序列，这样我们可以将学列当做一个栈使用。<br>下面给出一些关于栈使用的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char* cvSeqPush(CvSeq* seq, void* element&#x3D;NULL);</span><br><span class="line">char* cvSeqPushFront(CvSeq* seq, void* element&#x3D;NULL);</span><br><span class="line">void cvSeqPop(CvSeq* seq, void* element&#x3D;NULL);</span><br><span class="line">void cvSeqPopFront(CvSeq* seq, void* element&#x3D;NULL);</span><br><span class="line">void cvSeqPushMulti(CvSeq* seq, void* elements, int count, int in_front&#x3D;0);</span><br><span class="line">void cvSeqPopMulti(CvSeq* seq, void* elements, int count, int in_front&#x3D;0);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>插入和删除元素</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char* cvSeqInsert(CvSeq* seq, int before_index), void* element&#x3D;NULL;</span><br><span class="line">void cvSeqRemove(CvSeq* seq, int index);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>序列中块的大小</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 改变块的大小</span><br><span class="line">void cvSetSeqBlockSize(CvSeq* seq, int delta_elems);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>序列的读取和写入</strong></li>
</ul>
<p>当使用序列时，如果需要最高的性能，可以使用一些特殊的函数修改序列。这些函数通过专门的结构来保存序列的当前状态，这样使得很多后续操作都可以在更短的时间内完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化序列写结构CvSeqWriter</span><br><span class="line">void cvStartWriteSeq(</span><br><span class="line">    int seq_flags,</span><br><span class="line">    int header_size,</span><br><span class="line">    int elem_size,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    CvSeqWriter* writer</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 初始化写状态结构到序列的末尾</span><br><span class="line">void cvStartAppendToSeq(CvSeq* seq, CvSeqWriter* writer);</span><br><span class="line">&#x2F;&#x2F; 关闭写状态，使得写入生效</span><br><span class="line">CvSeq* cvEndWriteSeq(CvSeqWriter* writer);</span><br><span class="line">&#x2F;&#x2F; 刷新写操作</span><br><span class="line">void cvFlushSeqWriter(CvSeqWriter* writer);</span><br><span class="line">&#x2F;&#x2F; 写入元素</span><br><span class="line">CV_WRITE_SEQ_ELEM(elem, writer);</span><br><span class="line">CV_WRITE_SEQ_ELEM_VAR(elem_ptr, writer);</span><br></pre></td></tr></table></figure>



<p>与之对应的读操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化读结构</span><br><span class="line">void cvStartReadSeq(</span><br><span class="line">    const CvSeq* seq,</span><br><span class="line">    CvSeqReader* reader,</span><br><span class="line">    int reverse&#x3D;0</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 返回读状态在序列中当前的位置</span><br><span class="line">int cvGetSeqReaderPos(CvSeqReader* reader);</span><br><span class="line">&#x2F;&#x2F; 设置读操作的新位置</span><br><span class="line">void cvSetSeqReaderPos(CvSeqReader* reader, int index, int is_relative&#x3D;0);</span><br><span class="line">&#x2F;&#x2F; 读取元素</span><br><span class="line">CV_NEXT_SEQ_ELEM(elem_size, reader);</span><br><span class="line">CV_PREV_SEQ_ELEM(elem_size, reader);</span><br><span class="line">CV_READ_SEQ_ELEM(elem, reader);</span><br><span class="line">CV_REV_READ_SEQ_ELEM(elem, reader);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>序列和数组</strong></li>
</ul>
<p>有时候可能需要将序列转换成数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 复制序列的全部或部分到一个连续内存数组中</span><br><span class="line">void* cvCvtSeqToArray(</span><br><span class="line">    const CvSeq* seq,</span><br><span class="line">    void* elements,</span><br><span class="line">    CvSlice slice&#x3D;CV_WHOLE_SEQ</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 将数组转换为序列</span><br><span class="line">CvSeq* cvMakeSeqHeaderForArray(</span><br><span class="line">    int seq_type,</span><br><span class="line">    int header_size,</span><br><span class="line">    int elem_size,</span><br><span class="line">    void* elements,</span><br><span class="line">    int total,</span><br><span class="line">    CvSeq* seq,</span><br><span class="line">    CvSeqBlock* block</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="查找轮廓"><a href="#查找轮廓" class="headerlink" title="查找轮廓"></a>查找轮廓</h4><p>一个轮廓一般对应一系列的点，也就是图像中的一条曲线。表示方法可能根据不同情况而有所不同。有多种方法可以表示曲线。在OpenCV中一般用序列来存储轮廓信息。序列中的每一个元素是曲线中一个点的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 寻找轮廓函数</span><br><span class="line">int cvFindContours(</span><br><span class="line">    IplImage* img,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    CvSeq** firstContour,</span><br><span class="line">    int headerSize&#x3D;sizeof(CvContour),</span><br><span class="line">    CvContourRetrievalMode mode&#x3D;CV_RETR_LIST,</span><br><span class="line">    CvChainApproxMethod method&#x3D;CV_CHAIN_APPROX_SIMPLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>使用序列表示轮廓</strong></li>
</ul>
<p>序列中保存一系列的点，这些点构成轮廓。轮廓是点的序列，可以用来表示图像空间中的曲线。<br>常用的处理函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 与CVFindContours()类似，不过每次返回一个轮廓</span><br><span class="line">CvContourScanner cvStartFindContours(</span><br><span class="line">    CvArr* image,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    int header_size&#x3D;sizeof(CvContour),</span><br><span class="line">    int mode&#x3D;CV_RETR_LIST,</span><br><span class="line">    int method&#x3D;CV_CHAIN_APPROX_SIMPLE,</span><br><span class="line">    CvPoint offset&#x3D;cvPoint(0,0)</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 查找下一个轮廓</span><br><span class="line">CvSeq* cvFindNextContour(CvContourScanner scanner);</span><br><span class="line">&#x2F;&#x2F; 轮廓替换</span><br><span class="line">void cvSubstituteContour(CvContourScanner scanner, CvSeq* new_counter);</span><br><span class="line">&#x2F;&#x2F; 结束查找</span><br><span class="line">CvSeq* cvEndFindContour(CvContourScanner* scanner);</span><br><span class="line">&#x2F;&#x2F; 将Freeman链转换为多边形表示</span><br><span class="line">CvSeq* cvApproxChains(</span><br><span class="line">    CvSeq* src_seq,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    int method&#x3D;CV_CHAIN_APPROX_SIMPLE,</span><br><span class="line">    double parameter&#x3D;0,</span><br><span class="line">    int minimal_perimeter&#x3D;0,</span><br><span class="line">    int recursive&#x3D;0</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Freeman链码</strong></li>
</ul>
<p>一般情况下，通过cvFindContours获取的轮廓是一系列顶点的序列。另一种表达方法是当mehod设置为CV_CHAIN_CODE时，生成的轮廓是通过Freeman链码的方式返回。在Freeman链码中，多边形被表示为一系列的位移，每一个位移有8个方向，使用0-7表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化Freeman链cvChainPtReader结构</span><br><span class="line">void cvStartReadChainPoints(CvChain* chain, CvChainPtReader* reader);</span><br><span class="line">&#x2F;&#x2F; 读取链码中的每个点</span><br><span class="line">CvPoint cvReadChainPoint(CvChainPtReader* reader);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>绘制轮廓</strong></li>
</ul>
<p>一个经常用到的功能是在屏幕上绘制检测到的轮廓。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void cvDrawContours(</span><br><span class="line">    CvArr* img,</span><br><span class="line">    CvSeq* contour,</span><br><span class="line">    CvScalar external_color,</span><br><span class="line">    CvScalar holo_color,</span><br><span class="line">    int max_level,</span><br><span class="line">    int thickness&#x3D;1,</span><br><span class="line">    int line_type&#x3D;8,</span><br><span class="line">    CvPoint offset&#x3D;cvPoint(0, 0)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="深入分析轮廓"><a href="#深入分析轮廓" class="headerlink" title="深入分析轮廓"></a>深入分析轮廓</h4><p>当分析一个图像的时候，针对轮廓常用的操作有识别和处理，另外相关的还有多种对轮廓的处理，如简化或拟合轮廓，匹配轮廓到模板。</p>
<ul>
<li><strong>多边形逼近</strong></li>
</ul>
<p>当我们绘制一个多边形或者进行形状分析的时候，通常需要使用多边形逼近一个轮廓，使得定点数目变少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 轮廓逼近函数</span><br><span class="line">CvSeq* cvApproxPoly(</span><br><span class="line">    const void* src_seq,</span><br><span class="line">    int header_size,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    int method,</span><br><span class="line">    double parameter,</span><br><span class="line">    int recursive&#x3D;0</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 寻找关键点函数</span><br><span class="line">CvSeq* cvFindDominantPoints(</span><br><span class="line">    CvSeq* contour,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    int method&#x3D;CV_DOMINANT_IPAN,</span><br><span class="line">    double parameter1&#x3D;0,</span><br><span class="line">    double parameter2&#x3D;0,</span><br><span class="line">    double parameter3&#x3D;0,</span><br><span class="line">    double parameter4&#x3D;0,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>特性概括</strong></li>
</ul>
<p>轮廓处理中经常遇到的另一个任务是计算一些轮廓变化的概括特性。这可能包含长度或其他一些反映轮廓整体大小的度量。另一个有用的特性是轮廓矩，可以用来概括轮廓的总形状特性。<br><strong>长度</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算轮廓的长度</span><br><span class="line">double cvArcLength(const void* curve, CvSlice slice&#x3D;CV_WHOLE_SEQ, int is_closed&#x3D;-1);</span><br><span class="line">&#x2F;&#x2F; 计算轮廓的面积</span><br><span class="line">double cvContourArea(const CvArr* contour, CvSlice slice&#x3D;CV_WHOLE_SEQ);</span><br></pre></td></tr></table></figure>



<p><strong>边界框</strong><br>长度和面积只是轮廓的简单特性，更复杂一些的特性描述应该是矩形边界框，圆形边界框或椭圆边界框。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取矩形边界框</span><br><span class="line">CvRect cvBoundingRect(CvArr* points, int update&#x3D;0);</span><br><span class="line">&#x2F;&#x2F; 获取一个包围轮廓最小的长方形</span><br><span class="line">CvBox2D cvMInAreaRect2(const CvArr* points, cvMemStorage* storage&#x3D;NULL);</span><br><span class="line">&#x2F;&#x2F; CvBox2D结构体的定义</span><br><span class="line">typedef struct CvBox2D(</span><br><span class="line">    CvPoint2D32f center;</span><br><span class="line">    CvSize2D32f size;</span><br><span class="line">    float angle;</span><br><span class="line">) cvBox2D;</span><br></pre></td></tr></table></figure>



<p><strong>圆形和椭圆形边界</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取圆形外接圆</span><br><span class="line">int cvMInEnclosingCircle(</span><br><span class="line">    const CvArr* points,</span><br><span class="line">    CvPoint2D32f* center,</span><br><span class="line">    float* radius</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 获取最佳拟合椭圆</span><br><span class="line">CvBox2D cvFitEllipse2(const CvArr* points);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>几何</strong></li>
</ul>
<p>在处理CVBox2D或多边形边界的时候，经常需要进行多边形以及边界框的重叠判断。下面是一些常用的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据输入的2个矩形计算，得出最小外包矩形</span><br><span class="line">CvRect cvMaxRect(const CvRect* rect1, const CvRect* rect2);</span><br><span class="line">&#x2F;&#x2F; 计算矩形的四个顶点</span><br><span class="line">void cvBOxPoints(CvBox2D box, CvPoint2D32f pt[4]);</span><br><span class="line">&#x2F;&#x2F; 从mat中初始化序列</span><br><span class="line">CvSeq* cvPointSeqFromMat(</span><br><span class="line">    int seq_kind,</span><br><span class="line">    const CvArr* mat,</span><br><span class="line">    CvContour* contour_header,</span><br><span class="line">    CvSeqBlock* block</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 测试一个点是否在多边形内部</span><br><span class="line">double cvPointPolygonTest(</span><br><span class="line">    const CvArr* contour,</span><br><span class="line">    CvPoint2D32f pt,</span><br><span class="line">    int measure_dist</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="轮廓的匹配"><a href="#轮廓的匹配" class="headerlink" title="轮廓的匹配"></a>轮廓的匹配</h4><p>在实际应用中，一个跟轮廓相关的最常用到的功能是匹配两个轮廓。如果有两个轮廓，如何比较它们；或者如何比较一个轮廓和一个抽象模板。</p>
<ul>
<li><strong>矩</strong></li>
</ul>
<p>比较两个轮廓最简洁的方式是比较它们的轮廓矩。简单的说，矩是通过对轮廓上所有点进行积分运算而得到的一个粗略特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算轮廓矩</span><br><span class="line">void cvContoursMoments(CvSeq* contour, CvMoments* moments);</span><br><span class="line">&#x2F;&#x2F; 用于保存结果的CvMoments结构的定义</span><br><span class="line">typedef struct CvMoments&#123;</span><br><span class="line">    double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;</span><br><span class="line">    double mu20, mu11, mu02, mu30, mu21, mu12, mu03;</span><br><span class="line">    double inv_sqrt_m00;</span><br><span class="line">&#125; CvMoments;</span><br><span class="line">&#x2F;&#x2F; 获取特定的矩</span><br><span class="line">double cvGetSpatialMoment(CvMoments* moments, int x_order, int y_order);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>再论矩</strong></li>
</ul>
<p>直接计算得到的矩并不是做比较时最好的参数。具体来说，经常会用到的是归一化的矩，因此，不同大小但是形状相同的物体会有相同的值，并且不依赖于坐标系的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算图像的矩</span><br><span class="line">void cvMoments(const CvArr* image, CvMoments* moments, int isBinary&#x3D;0);</span><br><span class="line">&#x2F;&#x2F; 计算中心距</span><br><span class="line">double cvGetCentralMoment(CvMomens* moments, int x_order, int y_order);</span><br><span class="line">&#x2F;&#x2F; 计算归一化矩</span><br><span class="line">double cvGetNormalizedCentralMoment(CvMomens* moments, int x_order, int y_order);</span><br><span class="line">&#x2F;&#x2F; 计算Hu不变矩</span><br><span class="line">void cvGetHuMoments(CvMoments* moments, CvHuMoments* HuMoments);</span><br></pre></td></tr></table></figure>



<p>Hu矩是归一化中心矩的线性组合。之所以这样做是为了能够获取代表图像某个特征的矩函数，这些矩函数对某些变化如缩放、旋转和镜像映射具有不变形。</p>
<ul>
<li><strong>使用Hu矩进行匹配</strong></li>
</ul>
<p>很自然，使用Hu矩我们想要比较两个物体并且判明它们是否相似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比较函数</span><br><span class="line">double cvMatchShapes(</span><br><span class="line">    const void* object1,</span><br><span class="line">    const void* object2,</span><br><span class="line">    int method,</span><br><span class="line">    double parameter&#x3D;0</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>提供的物体可以是灰度图像也可以是轮廓。如果是图像，会根据指定的方法先计算矩。</p>
<ul>
<li><strong>等级匹配</strong></li>
</ul>
<p>有时，简单的相似度度量(比如矩)并不足够，所以就引出了轮廓树。轮廓树是用来描述一个特定形状内各部分的等级。编码得到的二分轮廓树包含了原始轮廓的形状信息，一旦被建立，就可以很有效的对比两个轮廓。这个过程开始定义两个树节点的对应关系，然后比较对应节点的特性。最后的结果就是两个树的相似度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从轮廓生成轮廓树</span><br><span class="line">CvContourTree* cvCreateContourTree(</span><br><span class="line">    const CvSeq* contour,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    double threshold</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 从轮廓树生成轮廓</span><br><span class="line">CvSeq* cvContourFromContourTree(</span><br><span class="line">    const CvContourTree* tree,</span><br><span class="line">    CvMemStorage* storage,</span><br><span class="line">    CvTermCriteria criteria</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 轮廓树匹配</span><br><span class="line">double cvMatchContourTrees(</span><br><span class="line">    const CvContourTree* tree1,</span><br><span class="line">    const CvContourTree* tree2,</span><br><span class="line">    int method,</span><br><span class="line">    double threshold</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>轮廓的凸包和凸缺陷</strong></li>
</ul>
<p>另一个理解物体形状或轮廓的有用的方法是计算一个物体的凸包然后计算其凸缺陷。很多复杂物体的特性能很好的被这种缺陷表现出来。<br>下面是是三个关于凸包和凸缺陷的重要函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define CV_CLOCKWISE 1</span><br><span class="line">#define CV_COUNTER_CLOCKWISE 2</span><br><span class="line">&#x2F;&#x2F; 计算已知轮廓的凸包</span><br><span class="line">CvSeq* cvConvexHull2(</span><br><span class="line">    const CvArr* input,</span><br><span class="line">    void* hull_storage&#x3D;NULL,</span><br><span class="line">    int orientation&#x3D;CV_CLOCKWISE,</span><br><span class="line">    int return_points&#x3D;0</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 检查一个已知轮廓是否是凸的</span><br><span class="line">int cvCheckContourConvexity(const CvArr* contour);</span><br><span class="line">&#x2F;&#x2F; 在已知轮廓是凸包的情况下计算凸缺陷</span><br><span class="line">CvSeq* cvConvexityDefects(&#39;</span><br><span class="line">    const CvArr* contour,</span><br><span class="line">    const CvArr* convexhull,</span><br><span class="line">    CvMemStorage* storage&#x3D;NULL</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 缺陷结构体的描述</span><br><span class="line">typedef struct CvConvexityDefect&#123;</span><br><span class="line">    CvPoint* start;</span><br><span class="line">    CvPoint* end;</span><br><span class="line">    CvPoint* depth_point;</span><br><span class="line">    float depth;</span><br><span class="line">&#125; CvConvexityDefect;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>成对几何直方图</strong></p>
<p>Freeman链码编码是对一个多边形的序列如何“移动”的描述，每个这样的移动有固定的长度和特定的方向。Freeman链码编码的用处很多，因为它支持了成对几何直方图(PGH)的基本思想。<br>PGH实际上是链码编码直方图(CCH)的一个扩展或延伸。CCH是一种直方图，用来统计一个轮廓Freeman链码编码每一种走法的数字。该直方图有旋转不变形的性质。<br>PGH的使用和FCC相似，一个重要的不同是，PGH的描述能力更强，因此在尝试解决复杂问题的时候很有用，比如说大量的形状需要被辨识，并且或者有很多背景噪声的时候。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算PGH的函数</span><br><span class="line">void cvCalaPGH(const CvSeq* contour, CvHistogram* hist);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC7%E7%AB%A0%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC7%E7%AB%A0%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">第7章 直方图与匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:25:31" itemprop="dateCreated datePublished" datetime="2020-07-17T14:25:31+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="直方图的基本数据结构"><a href="#直方图的基本数据结构" class="headerlink" title="直方图的基本数据结构"></a>直方图的基本数据结构</h4><p>简单的说，直方图就是对数据进行统计，将统计值组织到一系列事先定义好的bin中。bin中的数值是从数据中计算出的特征的统计量，这些数据可以是诸如梯度、方向、色彩或任何其他特征。无论如何，直方图获得的是数据分布的统计图。通常直方图的维度要低于原始数据。</p>
<ul>
<li><p>直方图数据结构的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直方图数据结构</span><br><span class="line">typedef struct CvHistogram</span><br><span class="line">&#123;</span><br><span class="line">    int type;</span><br><span class="line">    CvArr* bins;</span><br><span class="line">    float thresh[CV_MAX_DIM][2];</span><br><span class="line">    float** thresh2;</span><br><span class="line">    CvMatND mat;</span><br><span class="line">&#125;</span><br><span class="line">CvHistogram;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的直方图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建直方图</span><br><span class="line">cvHistogram* cvCreateHist(int dims, int* sizes, int type, float** ranges&#x3D;NULL, int uniform&#x3D;1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定直方图的ranges值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定ranges值</span><br><span class="line">void cvSetHistBinRanges(CvHistogram* hist, float** ranges, int uniform&#x3D;1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据已给出数据创建直方图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvHistogram* cvMakeHistHeaderForArray(int dims, int* sizes, CvHistogram* hist, float* data, float** ranges&#x3D;NULL, int uniform&#x3D;1);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="访问直方图"><a href="#访问直方图" class="headerlink" title="访问直方图"></a>访问直方图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 访问直方图数据的函数</span><br><span class="line">double cvQueryHistValue_1D(CvHistogram* hist, int idx0);</span><br><span class="line">double cvQueryHistValue_2D(CvHistogram* hist, int idx0, int idx1);</span><br><span class="line">double cvQueryHistValue_3D(CvHistogram* hist, int idx0, int idx1, int idx2);</span><br><span class="line">double cvQueryHistValue_nD(CvHistogram* hist, int* idxN);</span><br><span class="line">float* cvGetHistValue_1D(CvHistogram* hist, int idx0);</span><br><span class="line">float* cvGetHistValue_2D(CvHistogram* hist, int idx0, int idx1);</span><br><span class="line">float* cvGetHistValue_3D(CvHistogram* hist, int idx0, int idx1, idx2);</span><br><span class="line">float* cvGetHistValue_nD(CvHistogram* hist, int idxN);</span><br></pre></td></tr></table></figure>

<h4 id="直方图的基本操作"><a href="#直方图的基本操作" class="headerlink" title="直方图的基本操作"></a>直方图的基本操作</h4><ul>
<li><p>直方图归一化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 归一化</span><br><span class="line">cvNormalizeHist(CvHistogram* hist, double factor);</span><br></pre></td></tr></table></figure>
</li>
<li><p>阈值处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阈值函数</span><br><span class="line">cvThreshHist(CvHistogram* hist, double factor);</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制直方图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 复制函数</span><br><span class="line">void cvCopyHist(const CvHistogram* src, CvHistogram** dst);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出直方图的最小值和最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvGetMinMaxHistValue(const CvHistogram* hist, float* min_value, float* max_value, int* min_idx&#x3D;NULL, int* max_idx&#x3D;NULL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动计算直方图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvCalcHist(IplImage** image, CvHistogram* hist, int accumulate&#x3D;0, const CvArr* mask&#x3D;NULL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对比两个直方图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 相似度对比</span><br><span class="line">double cvCompareHist(const CvHistogram* hist1, CvHistogram* hist2, int method);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中method有四种选择，相关(method=CV_COMP_CORREL)、卡方(method=CV_COMP_CHISQR)、直方图相交(method=CV_COMP_INTERSECT)、Bhattacharyya距离(method=CV_COMP_BHATTACHARYYA)。</p>
<h4 id="一些更复杂的策略"><a href="#一些更复杂的策略" class="headerlink" title="一些更复杂的策略"></a>一些更复杂的策略</h4><ul>
<li><p>陆地移动距离(EMD)<br>陆地移动距离是一种度量准则，它实际上度量的是怎样将一个直方图的形状转变为另一个直方图的形状。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; EMD函数</span><br><span class="line">float cvCalcEMD2(const CvArr* signature1, const CvArr* signature2, int distance_type, CvDistanceFunction distance_func&#x3D;NULL, const CvArr* cost_matrix&#x3D;NULL, CvArr* flow&#x3D;NULL, float* lower_bound&#x3D;NULL, void* userdata&#x3D;NULL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向投影<br>反向投影是一种记录像素点或像素块如何适应直方图模型中分布的方式。例如，我们有一个颜色直方图，可以利用反向投影在图像中找到该区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于像素点的反向投影函数</span><br><span class="line">void cvCalcBackProject(IplImage** image, CvArr* back_project, const CvHistogram* hist);</span><br><span class="line">&#x2F;&#x2F; 基于块的反向投影函数</span><br><span class="line">void cvCalcBackProjectPatch(IplImage** images, CvArr* dst, CvSize patch_size, CvHistogram* hist, int method, float factor);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板匹配<br>模板匹配不是基于直方图的，是通过在输入图像上滑动图像块对实际的图像块和输入图像进行匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板匹配函数</span><br><span class="line">void cvMatchTemplate(const CvArr* image, const CvArr* temp1, CvArr* result, int method);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中method有三种可选择方法，平方差匹配法(method=CV_TM_SQDIFF)、相关匹配法(method=CV_TM_CCORR)、相关匹配法(method=CV_TM_CCOEFF)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC6%E7%AB%A0%20%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC6%E7%AB%A0%20%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">第6章 图像变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-17 14:24:43 / 修改时间：14:24:59" itemprop="dateCreated datePublished" datetime="2020-07-17T14:24:43+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 卷积函数</span><br><span class="line">void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor&#x3D;cvPoint(-1, -1));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>卷积边界</strong></li>
</ul>
<p>对于卷积，存在的一个问题是如何处理卷积边界。通用的做法是，先将特定的图像轻微变大，然后以各种方式自动填充图像边界，也就是所谓的padding。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现padding的函数</span><br><span class="line">void cvCopyMakeBorder(const CvArr* src, CvArr* dst, CvPoint offset, int bordertype, CvScalar value&#x3D;cvScalarALL(0));</span><br></pre></td></tr></table></figure>



<p>Bordertype可以是CV_BORDER_CONSTANT或者CV_BORDER_REPLICATE。</p>
<h4 id="梯度和Sobel导数"><a href="#梯度和Sobel导数" class="headerlink" title="梯度和Sobel导数"></a>梯度和Sobel导数</h4><p>图像处理中一个最基本的卷积运算是导数的计算。通常来说，用来表达微分的最常用的操作是Soble微分算子，Sobel算子包含任意阶的微分以及融合偏导。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sobel算子函数原型</span><br><span class="line">cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size&#x3D;3);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Scharr滤波器</strong></li>
</ul>
<p>对于Sobel算子，当试图估计图像的方向导数时，往往不是很准确，当梯度角越接近水平或者垂直方向时，这样的不准确就更加明显。Scharr滤波器同sobel滤波器一样快，但是准确率更高，所以当利用3*3滤波器实现图像质量的时候应该使用Scharr滤波器。</p>
<h4 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h4><p>因为拉普拉斯算子可以用二次导数的形式定义，可假设其离散实现类似于二阶Sobel导数，所以OpenCV在计算拉普拉斯算子时可以直接使用Sobel算子，但是同时也提供了拉普拉斯算子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Laplace算子</span><br><span class="line">void cvLaplace(const CvArr* src, CvArr* dst, int apertureSize&#x3D;3);</span><br></pre></td></tr></table></figure>



<p>拉普拉斯算子一个通常的应用是检测“团块”。由于拉普拉斯算子的形式是沿着X和Y轴的二次导数的和，这就意味着周围是更高值的单点或者小块会将使这个函数值最大化，反过来说，周围是更低值的点将会是函数的负值最大化。<br>拉普拉斯算子也可以用于边缘检测。</p>
<h4 id="Canny算子"><a href="#Canny算子" class="headerlink" title="Canny算子"></a>Canny算子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; canny边缘检测算子</span><br><span class="line">void cvCanny(const CvArr* img, CvArr* edges, double lowThresh, double highThresh, int apertureSize&#x3D;3);</span><br></pre></td></tr></table></figure>

<h4 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h4><p>霍夫变换是一种在图像中寻找直线，圆及其他简单形状的方法。</p>
<ul>
<li><strong>霍夫线变换</strong></li>
</ul>
<p>霍夫线变换的基本理论是二值图像中的任何两点都可能是一些候选直线集合的一部分。如果要确定每条线进行参数化，例如一个斜率a和截距b，原始图像中华的一点会变换为（a,b）平面上的轨迹，轨迹上的点对应着所有过原始图像上点的直线。<br>OpenCV支持两种不同形式的霍夫变换：标准霍夫变换(SHT)和累计概率霍夫变换(PPHT)。两者可以通过一个函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 霍夫变换检测直线</span><br><span class="line">CvSeq* cvHoughLines2(CvArr* image, void* line_storage, int method, double rho, double theta, int threshold, double param1&#x3D;0, double param2&#x3D;0);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>霍夫圆变换</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 霍夫变换检测圆</span><br><span class="line">CvSeq* cvHoughCircles(CvArr* image, void* circle_storage, int method, double dp, double min_dist, double param1&#x3D;100, double param2&#x3D;300, int min_radius&#x3D;0, int max_dadius&#x3D;0);</span><br></pre></td></tr></table></figure>

<h4 id="重映射"><a href="#重映射" class="headerlink" title="重映射"></a>重映射</h4><p>在某些情况，需要把一幅图像中一个位置的像素重映射到另一个位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重映射函数</span><br><span class="line">void cvRemap(const CvArr* src, CvArr* dst, const CvArr* mapx, const CvArr* mapy, int flags&#x3D;CV_INTER_LINEAR | CV_WARP_FILL_OUTLERS, CvScalar fillval&#x3D;cvScalarAll(0));</span><br></pre></td></tr></table></figure>



<h4 id="拉伸、收缩、扭曲和旋转"><a href="#拉伸、收缩、扭曲和旋转" class="headerlink" title="拉伸、收缩、扭曲和旋转"></a>拉伸、收缩、扭曲和旋转</h4><p>在一些数据扩增的技术中离不开图像的几何操作，这些几何变换包括拉伸，扭曲，旋转等。一个任意的仿射变换可以表达为乘以一个矩阵再加上一个向量的形式。<br>仿射变换可以将矩形转换为平行四边形。它可以将矩形的边压扁但必须保持边是平行的，也可以将矩形旋转或者按比例变化。而透视变换提供了更大的灵活性，一个透视变换可以将矩形变成梯形。</p>
<ul>
<li><strong>仿射变换</strong></li>
</ul>
<p>有两种情况会用到仿射变换。第一种是有一幅想要转换的图像，第二种是我们有一个点序列并想以此计算出变换。</p>
<p><strong>稠密仿射变换</strong><br>对于第一种情况，显然输入和输出的格式是图像，并且隐含的要求是扭曲假设对于所使用的图像，其像素必须是其稠密的表现形式。这意味着图像扭曲必须进行一些插值运算以使输出的图像平滑并且看起来自然一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 稠密变换函数</span><br><span class="line">void cvWarpAffine(const CvArr* src, CvArr* dst, const CvMat* map_matirx, int flags&#x3D;CV_INTER_LINEAR | CV_WARP_FILL_OUTLIERS, CvScalar fillval&#x3D;cvScalarAll(0));</span><br><span class="line">&#x2F;&#x2F; 开销更小的稠密变换函数</span><br><span class="line">void cvGetQuadrangeleSubPix(const CvArr* src, CvArr* dst, const CvMat* map_matrix);</span><br><span class="line">&#x2F;&#x2F; 仿射映射矩阵的计算</span><br><span class="line">CvMat* cvGetAffineTransform(const CvPoint2D32f* pts_src, const CvPoint2D32f* pts_dst, CvMat* map_matrix);</span><br><span class="line">&#x2F;&#x2F; 仿射映射矩阵的计算2</span><br><span class="line">CvMat* cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, CvMat* map_matrix);</span><br></pre></td></tr></table></figure>



<p><strong>稀疏仿射变换</strong><br>对于稀疏映射（如，对一系列独立点的映射），一般采用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 稀疏映射函数</span><br><span class="line">void cvTransform(const CvArr* src, CvArr* dst, const CvMat* transmat, const CvMat* shiftvec&#x3D;NULL);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>透视变换</strong></li>
</ul>
<p><strong>密集透视变换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 密集透视变换函数</span><br><span class="line">void cvWarpPerspective(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags&#x3D;CV_INTER_LINERA+CV_WARP_FILL_OUTLIERS, CvScalar fillval&#x3D;cvScalarAll(0));</span><br><span class="line">&#x2F;&#x2F; 透视映射矩阵map_matrix的计算</span><br><span class="line">CvMat* cvGetPerspectiveTransform(const CvPoint2D32f* pts_src, const CvPoint2D32f* pts_dst, CvMat* map_matrix);</span><br></pre></td></tr></table></figure>



<p><strong>稀疏透视变换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 稀疏仿射变换</span><br><span class="line">void cvPerspectiveTransform(const CvArr* src, CvArr* dst, const CvMat* mat);</span><br></pre></td></tr></table></figure>



<h4 id="CartToPolar与PolarToCart"><a href="#CartToPolar与PolarToCart" class="headerlink" title="CartToPolar与PolarToCart"></a>CartToPolar与PolarToCart</h4><p>两者通常会被用于更复杂的变换之中，如cvLogPolar()。函数本身是将数值在笛卡尔空间和极性或者径向空间之间进行映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 笛卡尔空间映射到极性空间</span><br><span class="line">void cvCartToPolar(const CvArr* x, const CvArr* y, CvArr* magnitude, CvArr* angle&#x3D;NULL, int angle_in_degrees&#x3D;0);</span><br><span class="line">&#x2F;&#x2F; 极性空间映射到笛卡尔空间</span><br><span class="line">void cvPolarToCart(const CvArr* magnitude, const CvArr* angle, CvArr* x, CvArr* y, int angle_in_degrees&#x3D;0);</span><br></pre></td></tr></table></figure>



<h4 id="LogPolar"><a href="#LogPolar" class="headerlink" title="LogPolar"></a>LogPolar</h4><p>对于二维图像，Log-polar转换表示从笛卡尔坐标到极坐标的变换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对数极坐标转换函数</span><br><span class="line">void cvLogPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double m, int flags&#x3D;CV_INTER_LINEAR | CV_WARP_FILL_OUTFIERS);</span><br></pre></td></tr></table></figure>



<h4 id="离散傅里叶变换-DFT"><a href="#离散傅里叶变换-DFT" class="headerlink" title="离散傅里叶变换(DFT)"></a>离散傅里叶变换(DFT)</h4><p>函数cvDFT()可以计算输入是一维或二维数组时的FFT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现FFT函数</span><br><span class="line">void cvDFT(const CvArr* src, CvArr* dst, int flags, int nonzero_rows&#x3D;0);</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>频谱乘法</strong><br>在许多包含计算DFT的应用中，还必须将两个频谱中的每个元素分别相乘。由于DFT的结果是以其特殊的高密度格式封装，并且通常是复数，OpenCV通过cvMulSpectrums()函数解除它们的封装以及通过普通的矩阵操作来进行乘法运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将两个频谱对应元素相乘</span><br><span class="line">void cvMulSpectrums(const CvArr* src1, const CvArr* src2, CvArr* dst, int flags);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>卷积和DFT</strong><br>利用DFT可以大大加快卷积运算的速度，因为卷积定理说明空间域的卷积运算可以转换为频域的乘法运算。通常过程是，首先计算图像的傅里叶变换，然后计算卷积核的傅里叶变换，然后在变换域中以相对于图像像素数目的线性时间内进行卷积运算。</p>
</li>
</ul>
<h4 id="离散余弦变换-DCT"><a href="#离散余弦变换-DCT" class="headerlink" title="离散余弦变换(DCT)"></a>离散余弦变换(DCT)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 余弦变换函数</span><br><span class="line">void cvDCT(const CvArr* src, CvArr* dst, int flags);</span><br></pre></td></tr></table></figure>

<h4 id="积分图像"><a href="#积分图像" class="headerlink" title="积分图像"></a>积分图像</h4><p>积分图是一个数据结构，可实现子区域的快速求和。这样的求和在人脸识别及相关算法中应用的Haar小波变换是很用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 求积分图像</span><br><span class="line">void cvIntegral(const CvArr* image, CvArr* sum, CvArr* sqsum&#x3D;NULL, CvArr* tilted_sum&#x3D;NULL);</span><br></pre></td></tr></table></figure>



<h4 id="距离变换"><a href="#距离变换" class="headerlink" title="距离变换"></a>距离变换</h4><p>图像的距离变换被定义为一幅新图像，该图像的每个输出像素被设成与输入像素中0像素最近的距离。显然，典型的距离变换的输入应为某些边缘图像。在多数应用中，距离变换的输入是例如Canny边缘检测的检测图像的转换输出。<br>在实际应用中，距离变换通常是利用3x3或5x5数组掩模进行的。数组中的每个点被定义为这个特殊位置同其他相关的掩模中心的距离。较大的距离以由整个掩模定义的“动作”序列的形式被建立，这就意味着要用更大的掩模将生成更准确的距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 距离变换函数</span><br><span class="line">void cvDistTransform(const CvArr* src, CvArr* dst, int distance_type&#x3D;CV_DIST_L2, int mask_size&#x3D;3, const float* kernel&#x3D;NULL, CvArr* labels&#x3D;NULL);</span><br></pre></td></tr></table></figure>



<h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直方图均衡化函数</span><br><span class="line">void cvEqualizeHist(const CvArr* src, CvArr* dst);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC5%E7%AB%A0%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC5%E7%AB%A0%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">第5章 图像处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:23:53" itemprop="dateCreated datePublished" datetime="2020-07-17T14:23:53+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="平滑处理-模糊处理"><a href="#平滑处理-模糊处理" class="headerlink" title="平滑处理(模糊处理)"></a>平滑处理(模糊处理)</h4><p>平滑处理的用途有很多，最常见的是用来减少图像上的噪声或者失真。降低图像分辨率时，平滑处理很重要。目前OpenCV可提供五种不同的平滑操作，分别为简单模糊，简单无缩放变换的模糊，中值模糊，高斯模糊以及双边滤波。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 平滑操作实现函数</span><br><span class="line">void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype&#x3D;CV_GAUSSIAN, int param1&#x3D;3, int param2&#x3D;0, double param3&#x3D;0, double param4&#x3D;0);</span><br></pre></td></tr></table></figure>



<h4 id="图像形态学"><a href="#图像形态学" class="headerlink" title="图像形态学"></a>图像形态学</h4><ul>
<li><strong>膨胀和腐蚀</strong></li>
</ul>
<p>膨胀是指将一些图像（或图像中的一部分区域，称之为A）与核（称之为B）进行卷积。通常情况下，核是一个小的中间带有参考点的实心正方形或圆盘。核可以视为模板或掩码，膨胀是求局部最大值的操作。核B与图像卷积，即计算核B覆盖的区域的像素点最大值，并把这个最大值赋值给参考点指定的像素。这样就会使图像中的高亮区域逐渐增长。<br>腐蚀是膨胀的反操作。腐蚀操作要计算核区域像素的最小值。当核B与图像卷积时，计算被B覆盖区域的最小像素值，并把这个值放到参考点上。腐蚀能够消除细的凸起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 膨胀操作</span><br><span class="line">void cvErode(IplImage* src, IplImage* dst, IplConvKernel* B&#x3D;NULL, int iterations&#x3D;1);</span><br><span class="line">&#x2F;&#x2F; 腐蚀操作</span><br><span class="line">void cvDilate(IplImage* src, IplImage* dst, IplConvKernel* B&#x3D;NULL, int iterations&#x3D;1);</span><br><span class="line">&#x2F;&#x2F; 自定义核B</span><br><span class="line">IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values&#x3D;NULL);</span><br><span class="line">&#x2F;&#x2F; 释放自定义的核</span><br><span class="line">void cvReleaseStructuringElement(IplConvKernel** element);</span><br></pre></td></tr></table></figure>

<p>形态核与卷积核不同，不需要任何的数值填充核，它只是标明了计算最大值或最小值的范围。</p>
<ul>
<li><strong>更通用的形态学</strong></li>
</ul>
<p>基本的腐蚀和膨胀操作通常用于处理布尔图像和图像掩码。然而，在处理灰度或彩色图像时，往往需要一些额外的操作。<br><strong>开运算：</strong>先腐蚀再膨胀，通常可以用来统计二值图像中的区域数。开运算消除高于其邻近点的孤立点。<br><strong>闭运算：</strong>先膨胀再腐蚀，对于连通区域分析，通常先采用闭运算来消除纯粹由噪声引起的部分，然后用开运算来连接邻近的区域。闭运算消除低于其邻近点的孤立点。<br><strong>形态学梯度：</strong>对二值图像，可以将团块的边缘突出出来。能够描述图像亮度变化的剧烈程度。<br><strong>礼帽和黑帽：</strong>两者分别用于分离比邻近的点亮或暗的一些斑块。当试图孤立的部分相对于其邻近的部分有亮度变化时，就可以使用这些方法。礼帽操作是从A中减去了A的开运算。黑帽操作是A的闭运算减去A。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通用的形态学操作函数</span><br><span class="line">void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations&#x3D;1);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>漫水填充法</strong></li>
</ul>
<p>漫水填充法经常被用来标记或分离图像的一部分以便对其进行进一步处理或分析；也可以用来从输入图像获取掩码区域，掩码会加速处理过程，或只处理掩码指定的像素点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 填充算法函数原型</span><br><span class="line">void cvFloodFill(Iplimage* img, CvPoint seedPoint, CvScalar newVal, CvScalar loDiff&#x3D;cvScalarAll(0), CvScalar upDiff&#x3D;cvScalarAll(0), CvConnectedComp* comp&#x3D;4, CvArr* mask&#x3D;NULL);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>尺寸调整</strong></li>
</ul>
<p>cvResize()函数用于放大或缩小图像。该函数可以将源图像精确转换为目标图像的尺寸。如果源图像中设置了ROI，那么cvResize()将会对ROI区域调整尺寸，以匹配目标图像，同样，如果目标图像中已经设置ROI的值，那么cvResize()将会源图像进行尺寸调整并填充到目标图像的ROI中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cvRsize()函数原型</span><br><span class="line">void cvResize(const CvArr* src, CvArr* dst, int interpolation&#x3D;CV_INTER_LINEAR);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>图像金字塔</strong></li>
</ul>
<p>图像金字塔是一个图像集合，集合中所有的图像都源于同一个原始图像，而且是通过对原始图像连续降采样获得，直到达到某个终止条件才停止降采样。在应用中常有两种类型的图像金字塔：高斯金字塔和拉普拉斯金字塔。高斯金字塔用来向下降采样图像，而拉普拉斯金字塔则用来从金字塔底层图像中向上采样重建一个图像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从金字塔中上一级图像生成下一级图像，新图像面积会变为源图像的1&#x2F;4</span><br><span class="line">void cvPyrDown(IplImage* src, IplImage* dst, IplFilter filter&#x3D;CV_GAUSSIAN_5×5));</span><br><span class="line">&#x2F;&#x2F; 将现有的图像在每个维度都放大2倍</span><br><span class="line">void cvPyrUp(IplImage* src, IplImage* dst, IplFilter filter&#x3D;CV_GAUSSIAN_5×5);</span><br><span class="line">&#x2F;&#x2F; 利用金字塔实现图像分割</span><br><span class="line">void cvPySegmentation(IplImage* src, IplImage* dst, CvMemStorage* storage, CvSeg** comp, int level, double threshold1, double threshold2);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>阈值化</strong></li>
</ul>
<p>基本思想：给定一个数组和一个阈值，然后根据数组中的每个元素的值是低于还是高于阈值而进行一些处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double cvThreshold(CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type);</span><br></pre></td></tr></table></figure>



<p>对于有很强照明或反射梯度的图像，需要根据梯度进行阈值化时，往往需要自适应阈值技术。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自适应阈值函数原型</span><br><span class="line">void cvAdaptiveThreshold(CvArr* src, CvArr* dst, double max_val, int adaptive_method&#x3D;CV_ADAPTIVE_THRESH_MEAN_C, int threshold_type&#x3D;CV_THRESH_BINARY, int block_size&#x3D;3, double param1&#x3D;5);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC4%E7%AB%A0%20%E7%BB%86%E8%AF%B4HighGUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC4%E7%AB%A0%20%E7%BB%86%E8%AF%B4HighGUI/" class="post-title-link" itemprop="url">第4章 细说HighGUI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:20:27" itemprop="dateCreated datePublished" datetime="2020-07-17T14:20:27+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int cvNameWindow(const char* name, int flags&#x3D;CV_WINDOW_AUTOSIZE); &#x2F;&#x2F; 创建窗口</span><br><span class="line"></span><br><span class="line">void* cvGetWindowHandle(const char* name);</span><br><span class="line">const char* cvGetWindowName(void* window_handle); &#x2F;&#x2F; 获取窗口名称</span><br><span class="line"></span><br><span class="line">void cvResizeWindow(const char* name, int width, int height); &#x2F;&#x2F; 调整窗口大小</span><br></pre></td></tr></table></figure>

<h4 id="载入图像"><a href="#载入图像" class="headerlink" title="载入图像"></a>载入图像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IplImage* cvLoadImage(const char* filename, int iscolor&#x3D;CV_LOAD_IMAGE_COLOR); &#x2F;&#x2F; 从磁盘载入图像</span><br><span class="line"></span><br><span class="line">int cvSaveImage(const char* filename, const CvArr* image); &#x2F;&#x2F; 保存图像</span><br></pre></td></tr></table></figure>

<h4 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void cvShowImage(const char* name, const CvArr* image); &#x2F;&#x2F; 显示图像</span><br><span class="line">void cvMoveWindow(const char* name, int x, int y); &#x2F;&#x2F; 将窗口移动到其左上角为x, y的位置</span><br><span class="line">void cvDestroyAllWindows(void); &#x2F;&#x2F; 释放所有窗口</span><br><span class="line">int cvStartWindowThread(void); &#x2F;&#x2F; 创建一个线程用来自动更新窗口以及处理其他窗口触发事件</span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>鼠标事件响应采用回调函数的方式来处理。即，为了可以响应鼠标点击事件，首先必须创建一个回调函数，使鼠标点击事件发生时，OpenCV可以调用这个函数。创建这个函数之后，需要在OpenCV中注册这个函数，以便特定窗口被触发鼠标事件以后，OpenCV可以正确调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void CvMouseCallback(int event, int x, int y, int flags, void* param); &#x2F;&#x2F; 回调函数的定义</span><br><span class="line">void cvSetMouseCallback(const char* window_name, CvMouseCallback on_mouse, void* param&#x3D;NULL); &#x2F;&#x2F; 注册回调函数</span><br></pre></td></tr></table></figure>



<h4 id="Sliders-Trackbars-Switches"><a href="#Sliders-Trackbars-Switches" class="headerlink" title="Sliders, Trackbars, Switches"></a>Sliders, Trackbars, Switches</h4><p>滑动条的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建滑动条函数</span><br><span class="line">int cvCreateTrackbar(const char* trackbar_name, const char* window_name, int* value, int count, CvTrackbarCallback on_change);</span><br><span class="line">&#x2F;&#x2F; 读取滑动条的value值</span><br><span class="line">int cvGetTrackbarPos(const char* trackbar_name, const char* window_name);</span><br><span class="line">&#x2F;&#x2F; 设置滑动条的value值</span><br><span class="line">void cvSetTrackbarPos(const char* trackbar_name, const char* window_name, int pos);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/%E7%AC%AC3%E7%AB%A0%20%E5%88%9D%E6%8E%A2OpenCV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Tramac">
      <meta itemprop="description" content="Tramac写字的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tramac">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/%E7%AC%AC3%E7%AB%A0%20%E5%88%9D%E6%8E%A2OpenCV/" class="post-title-link" itemprop="url">第3章 初探OpenCV</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 14:19:46" itemprop="dateCreated datePublished" datetime="2020-07-17T14:19:46+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="OpenCV的基本数据类型"><a href="#OpenCV的基本数据类型" class="headerlink" title="OpenCV的基本数据类型"></a>OpenCV的基本数据类型</h4><ul>
<li><strong>基本数据类型</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">结构</th>
<th align="left">成员</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CvPoint</td>
<td align="left">int x, y</td>
<td align="left">图像中的点</td>
</tr>
<tr>
<td align="left">CvPoint2D32f</td>
<td align="left">float x, y</td>
<td align="left">二维空间中的点</td>
</tr>
<tr>
<td align="left">CvPoint3D32f</td>
<td align="left">float x, y， z</td>
<td align="left">三维空间中的点</td>
</tr>
<tr>
<td align="left">CvSize</td>
<td align="left">int width, height</td>
<td align="left">图像的尺寸</td>
</tr>
<tr>
<td align="left">CvRect</td>
<td align="left">int x, y, width, height</td>
<td align="left">图像的部分区域</td>
</tr>
<tr>
<td align="left">CvScalar</td>
<td align="left">double val[4]</td>
<td align="left">RGBA值</td>
</tr>
</tbody></table>
<h4 id="CvMat矩阵结构"><a href="#CvMat矩阵结构" class="headerlink" title="CvMat矩阵结构"></a>CvMat矩阵结构</h4><p>在OpenCV中没有向量（vector）结构，需要时可以用列矩阵代替。<br>矩阵由宽度（width），高度（height），类型（type），行数据长度（step）和一个指向数据的指针构成。</p>
<ul>
<li><strong>矩阵头的定义</strong>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typeded struct CvMat &#123;</span><br><span class="line">    int type;</span><br><span class="line">    int step;</span><br><span class="line">    int* refcount;</span><br><span class="line">    union &#123;</span><br><span class="line">        unchar* ptr;</span><br><span class="line">        short* s;</span><br><span class="line">        int* i;</span><br><span class="line">        float* fl;</span><br><span class="line">        double* db;</span><br><span class="line">    &#125;data;</span><br><span class="line">    union &#123;</span><br><span class="line">        int rows;</span><br><span class="line">        int height;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        int cols;</span><br><span class="line">        int width;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; CvMat;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>矩阵的创建与释放</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CvMat* cvCreateMat(int rows, int cols, int type); </span><br><span class="line">CvMat* cvCreateMatHeader(int rows, int cols, int type); &#x2F;&#x2F;只创建CvMat结构，不分配存储空间</span><br><span class="line">CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data&#x3D;NULL, int step&#x3D;CV_AUTOSTEP); &#x2F;&#x2F;在已存在的结构上初始化CvMat矩阵头</span><br><span class="line">CvMat* cvCloneMat(const CvMat* mat); &#x2F;&#x2F; 克隆</span><br><span class="line">void cvReleaseMat(CvMat** mat); &#x2F;&#x2F; 释放</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>矩阵数据的存取</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float element_3_2 &#x3D; CV_MAT_ELEM(*mat, float, 3, 2);</span><br><span class="line">uchar* cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type&#x3D;NULL); &#x2F;&#x2F; 返回指向所需元素的指针</span><br><span class="line">double cvGetReal2D(const CvArr* arr, int indx0, int idx1); &#x2F;&#x2F; 返回矩阵元素的实际值</span><br><span class="line">CvScalar cvGet2D(const CvArr* arr, int idx0, int idx1); &#x2F;&#x2F; 返回CvScalar类型</span><br><span class="line"></span><br><span class="line">void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value); &#x2F;&#x2F; 设置值</span><br><span class="line">void cvSet2D(CvArr* arr, int idx0, int idx1, CvScalar value);</span><br></pre></td></tr></table></figure>

<h4 id="IplImage数据结构"><a href="#IplImage数据结构" class="headerlink" title="IplImage数据结构"></a>IplImage数据结构</h4><ul>
<li><strong>IplImage结构</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IplImage &#123;</span><br><span class="line">    int nSize;</span><br><span class="line">    int ID;</span><br><span class="line">    int nChannels;</span><br><span class="line">    int alphaChannel;</span><br><span class="line">    int depth;</span><br><span class="line">    char colorModel[4];</span><br><span class="line">    char dataOrder;</span><br><span class="line">    int origin;</span><br><span class="line">    int align;</span><br><span class="line">    int width;</span><br><span class="line">    int height;</span><br><span class="line">    struct _IplROI *roi;</span><br><span class="line">    struct _IplImage *maskROI;</span><br><span class="line">    void *imageId;</span><br><span class="line">    struct _IplTileInfo *tileInfo;</span><br><span class="line">    int imageSize;</span><br><span class="line">    char *imageData;</span><br><span class="line">    int widthStep;</span><br><span class="line">    int BorderMode[4];</span><br><span class="line">    int BorderConst[4];</span><br><span class="line">    char *imageDataOrigin;</span><br><span class="line">&#125; IplImage;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ROI的设置与重置</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvSetImageROI(IplImage* image, CvRect rect); &#x2F;&#x2F; 设置ROI</span><br><span class="line">void cvResetImageROI(IplImage* image); &#x2F;&#x2F; 取消ROI</span><br></pre></td></tr></table></figure>

<h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><ul>
<li><strong>直线</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvLine(CvArr* array, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness&#x3D;1, int connectivity&#x3D;8); &#x2F;&#x2F; 直线</span><br><span class="line">void cvRectangle(CvArr* array, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness&#x3D;1); &#x2F;&#x2F; 矩形</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>圆形和椭圆</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvCircle(CvArr* array, CvPoint center, int radius, CvScalar color, int thickness&#x3D;1, int connectivity&#x3D;8); &#x2F;&#x2F; 圆形</span><br><span class="line">void cvEllipse(CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness&#x3D;1, int line_type&#x3D;8); &#x2F;&#x2F; 椭圆</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多边形</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvFillPoly(CvArr* img, CvPoint** pts, int* npts, int contours, CvScalar color, int line_type&#x3D;8); &#x2F;&#x2F; 多边形</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字体和文字</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvPutText(CvArr* img, const char* text, CvPoint origin, const CvFont* font, CvScalr color); &#x2F;&#x2F; 图像上输出文本</span><br></pre></td></tr></table></figure>

<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><ul>
<li><strong>矩阵的存储和读取</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CvMat A &#x3D; cvMat(5, 5, CV_32F, the_matrix_data); &#x2F;&#x2F; 创建矩阵</span><br><span class="line">cvSave(&quot;my_matrix.xml&quot;, &amp;A); &#x2F;&#x2F; 存储矩阵</span><br><span class="line">CvMat* A1 &#x3D; (CvMat*) cvLoad(&quot;my_matrix.xml&quot;); &#x2F;&#x2F; 读取矩阵</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>xml格式文件的新建，存储与读取</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tramac"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Tramac</p>
  <div class="site-description" itemprop="description">Tramac写字的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tramac" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tramac" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tramac</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
